---
title: "S21-L2: エージェンティックコーディングの危険性"
description: "コーディングエージェントが生成するコードのセキュリティ品質を分析したTenzaiのベンチマーク結果を基に，AIコード生成の課題と開発者の責任を解説します"
sectionNumber: 21
sectionTitle: "Agent Security"
lectureNumber: 2
lectureTitle: "The Bad of Agentic Coding"
udemyLectureId: 54622225
difficulty: "advanced"
tags: ["security", "coding-agents", "vulnerabilities", "authorization", "ssrf", "csrf", "tenzai"]
category: "security"
order: 2102
---

import Quiz from '@/components/content/Quiz.astro'

## 概要

Cursor，Claude Code，Codex，Replit，Devinなどのコーディングエージェントが生成するコードのセキュリティ品質を，Tenzaiのベンチマーク結果を基に分析します．15のアプリケーションから69の脆弱性が発見された結果を通じて，エージェントが得意な分野と苦手な分野，そして開発者の責任について学びます．

## ベンチマークの概要

セキュリティ企業Tenzai（AI駆動の侵入テストプラットフォーム）が，5つの主要なコーディングエージェントで同一のアプリケーションを構築し，セキュリティ品質を比較しました．

### テスト方法

1. プロンプト1: 技術スタックと基本設計
2. プロンプト2: RBAC（ロールベースアクセス制御）と追加機能の実装
3. プロンプト3: 追加ロールと機能の実装

反復的な開発プロセスをシミュレートし，生成されたアプリケーションをTenzaiのAIエージェントで分析しました．

### 結果

- 合計69の脆弱性を発見
- すべてのコーディングエージェントが脆弱なコードを生成
- 認証の不備，SSRF，セキュリティ制御の欠如など

```text
┌──────────────────────────────────────────────────┐
│     コーディングエージェントのセキュリティ品質      │
├──────────────────────────────────────────────────┤
│  得意（Good）            │  苦手（Bad/Ugly）       │
│                          │                        │
│  - SQLインジェクション防止  │  - 認可の不備          │
│  - XSS防止（フレームワーク）│  - ビジネスロジック検証  │
│                          │  - SSRF                │
│  明確な解決策がある場合    │  - CSRF保護の欠如       │
│  → 正しいコードを生成     │  - レート制限の欠如     │
│                          │  判断が必要な場合        │
│                          │  → 脆弱なコードを生成   │
└──────────────────────────────────────────────────┘
```

## エージェントが得意な領域（Good）

明確な解決策が存在する脆弱性クラスに対しては，コーディングエージェントは効果的です:

### SQLインジェクション

エージェントは一貫してパラメータ化クエリを使用しました:

```python
# 安全なコード（パラメータ化クエリ）
cursor.prepare("SELECT * FROM users WHERE username = ?")
cursor.execute(username)
```

テンプレートとユーザー入力を分離することで，SQLインジェクションを防止しています．

### クロスサイトスクリプティング（XSS）

エージェントのコードは入力のサニタイズを行わないことがありましたが，フロントエンドフレームワークが適切にエスケープ処理を行うため，脆弱性が実際には悪用不可能でした．

### ポイント

フレームワークに明確な「やるべきこと・やってはいけないこと」が定義されている場合，エージェントは正しいコードを生成する傾向があります．

## エージェントが苦手な領域（Bad）

明確な解決策が存在しない脆弱性に対しては，エージェントは大きく失敗します:

### 認可（Authorization）の問題

5つのエージェントすべてが認可に関する脆弱性を導入しました．

#### 例1: ロールチェックの不備

```javascript
// Codexが生成した脆弱なコード
if (user.role === "shopper" && user.id !== order.userId) {
  throw new ForbiddenError();
}
return order; // sellerロールは全ての注文にアクセス可能！
```

`shopper` ロール以外（例: `seller`）はチェックをバイパスし，全注文にアクセスできてしまいます．

#### 例2: 認証なしのアクセス

```javascript
// Claude Codeが生成した脆弱なコード
if (user) {
  // 認証済みユーザーのみ権限チェック
  if (user.role !== "admin" && user.role !== "seller") {
    return "Failed to delete";
  }
}
// 認証されていないユーザーはチェックをスキップして削除可能！
await deleteProduct(productId);
```

鍵付きのドアを開けっぱなしにしているようなものです．認証されていないユーザーが何でもできてしまいます．

### ビジネスロジックの脆弱性

エージェントはビジネスロジックの脆弱性に非常に弱いです:

- 5つ中4つのエージェントが，注文数量が正の値であることを検証しなかった
- 5つ中3つのエージェントが，商品価格が負の値にならないことを検証しなかった

```python
# 脆弱なコード: バリデーションなし
cursor.execute(
    "INSERT INTO products (name, price) VALUES (?, ?)",
    (name, price)  # priceが負でもそのまま保存
)
```

## 未解決の脆弱性クラス（Ugly）

### SSRF（サーバーサイドリクエストフォージェリ）

5つのエージェントすべてがSSRF脆弱性を導入しました．リンクプレビュー機能のように，ユーザーが提供するURLをサーバーがフェッチする機能では:

- 許可リストなしではすべてのエージェントが脆弱なコードを生成
- 明示的に許可リストの実装を指示すれば成功する
- セキュリティアプローチをエージェントの判断に任せると失敗する

### セキュリティ制御の完全な欠如

最も懸念される発見は，エージェントが「書かなかったコード」に存在する脆弱性でした:

| セキュリティ制御 | 実装状況 |
|---|---|
| CSRF保護 | すべてのエージェントが未実装 |
| セキュリティヘッダー | 未実装 |
| ログインレート制限 | ほぼすべてが未実装 |
| アカウントロックアウト | 未実装 |

Claude Codeが1つのケースでレート制限を実装しましたが，X-Forwarded-Forヘッダーでバイパス可能でした．

## 開発者の責任

### 核心的な教訓

- コーディングエージェントは明示的に指示された機能を合理的に安全な方法で構築する
- しかし，全体像を把握してプロアクティブに防御メカニズムを導入することはできない
- セキュリティの責任は開発者にある，エージェントやLLMにはない

### 推奨されるアプローチ

1. エージェントにセキュリティの全責任を委ねない
2. 認可，レート制限などのセキュリティ制御は明示的に指示する
3. 生成されたコードを必ずレビューし，セキュリティを検証する
4. セキュリティテスト（自動化されたペネトレーションテスト）を導入する
5. 「シフトレフト」: コーディング段階でセキュリティ問題を捕捉する

## まとめ

- すべてのコーディングエージェントが脆弱性のあるコードを生成する
- SQLインジェクションやXSSなど明確な解決策がある脆弱性には比較的強い
- 認可，ビジネスロジック，SSRFなど判断が必要な脆弱性には非常に弱い
- CSRF保護やレート制限などのセキュリティ制御を自発的に実装しない
- セキュリティの責任は開発者にあり，エージェントに委ねるべきではない
- 明示的なセキュリティ指示とコードレビューが不可欠

<Quiz questions={[
  {
    question: "Tenzaiのベンチマークで5つのコーディングエージェントから発見された脆弱性の合計数はどれですか？",
    options: [
      "15個",
      "35個",
      "69個",
      "100個以上"
    ],
    answer: 2,
    explanation: "Tenzaiのベンチマークでは，5つの主要なコーディングエージェントで構築された15のアプリケーションから合計69の脆弱性が発見されました．"
  },
  {
    question: "コーディングエージェントがSQLインジェクションに強い理由は何ですか？",
    options: [
      "SQLを使用しないコードを生成するため",
      "明確な解決策（パラメータ化クエリ）が存在し，エージェントが一貫して使用するため",
      "データベースへのアクセスを禁止するため",
      "入力バリデーションを自動的に追加するため"
    ],
    answer: 1,
    explanation: "SQLインジェクションにはパラメータ化クエリという明確な解決策があり，フレームワークの「やるべきこと・やってはいけないこと」が定義されているため，エージェントは正しいコードを生成します．"
  },
  {
    question: "5つのエージェントすべてが未実装だったセキュリティ制御はどれですか？",
    options: [
      "SQLインジェクション防止",
      "パスワードハッシュ化",
      "CSRF保護",
      "HTTPS通信"
    ],
    answer: 2,
    explanation: "CSRF保護はすべてのエージェントが未実装でした．エージェントは明示的に指示されない限り，プロアクティブにセキュリティ制御を導入しません．"
  },
  {
    question: "認可の脆弱性についてのベンチマーク結果として正しいものはどれですか？",
    options: [
      "1つのエージェントだけが脆弱だった",
      "5つのエージェントすべてが認可に関する脆弱性を導入した",
      "認可の脆弱性は発見されなかった",
      "3つのエージェントが完璧な認可を実装した"
    ],
    answer: 1,
    explanation: "5つのエージェントすべてが認可に関する脆弱性を導入しました．認可は判断が必要な領域で，明確な解決策がないためエージェントが失敗しやすい分野です．"
  },
  {
    question: "このベンチマークからの核心的な教訓は何ですか？",
    options: [
      "コーディングエージェントは完全に安全なコードを生成する",
      "セキュリティの責任は開発者にあり，エージェントに委ねるべきではない",
      "エージェントを使わない方が安全",
      "セキュリティテストは不要"
    ],
    answer: 1,
    explanation: "コーディングエージェントは明示的に指示された機能を合理的に安全な方法で構築しますが，全体像を把握してプロアクティブに防御メカニズムを導入することはできません．セキュリティの責任は開発者にあります．"
  }
]} />
