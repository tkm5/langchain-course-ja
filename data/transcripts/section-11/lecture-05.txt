Eden: Hey, there, Eden here. And in this video, we're going to cover, from the theoretical point of view, the core components of LangGraph. And this is super important because right after this video, we're going to start implementing project using those components. Alright, so with LangGraph, we're going to be implementing a well-defined control flow or a state machine or a graph. You can call it whatever you want. But the basic idea here is that within this well-defined and well scoped control flow, we're going to be leveraging LLMs and they're going to have a very crucial role. So LLMs are either going to define in the control flow where we're going to go next. So this is going to be non-deterministic, or we can even, in this control flow, execute LLM calls or agent calls. And to get started, we need three LangGraph core components: nodes, edges, and conditional edges. Nodes are literally python functions. So you can put here any code you want. This code can be deterministic code, regular Python code, it can be Python code that calls an LLM, or it can even be an LLM agent. But you have full flexibility of what you want to do inside the nodes. Edges connect those nodes within the graphs execution and conditional edges are helped to make decisions whether to go to node A or to node B, and this is dynamic and can be very, very flexible. And this is the power of LangGraph. So we have full control of how we're going to navigate in this graph execution. Cool. Two important built-in LangGraph nodes are the start node and the end node. And the start node is the entry point for our graph execution. So we're going to start from there and the end node is going to be the last node that is going to be executed. And both of those nodes don't really do anything. So you can think about them as no operation. One of the most important concepts in LangGraph is the state or the agent state. And the state is simply a dictionary that is going to have information that is important for us to keep tracking the graph. Maybe some nodes execution results, maybe some temporary results or even our chat history. It can be fairly simple like only storing the chat history, so the results of the LLMs every time, or it could be very complex and we can customize it to anything we want. It is local to the graph that is it is available for every node to access within our graph's execution. And it is also available on each edge and it can be local. So within our graph execution in our runtime. However, we can also persist it into persistent storage. So if you want to stop for some reason, the flow execution of the graph and we want to continue from that same point with that given state, we can do it with persistence and we're going to show you that in the course. Alright, so remember that I told you that every node in LangGraph is a function and we can write there whatever we want. This is still the case, but nodes are special functions that always receive as an input, the current graph state, which is going to have all the information that the node needs in order to do its work. And what this function returns the node function, it's updating the state, so it always returns a dictionary with the keys of what do we want to update in our state. And the result of this is that in LangGraph, every node is going to update the state. So the state object is going to change over time and the conditional edges and the edges are going to rely on the states whether to go to node A or to node B. And this is how our software is going to look like. So with these core components, we can build very advanced things. Alright, so more concepts that are important for the rest of the course is, first, a cyclic graph. So with LangGraph, we can also implement loops and this is very powerful, which is something that with LangChain was super hard to do, and we're going to later discuss this in the course. Also human in the loop. So if we want to get human feedback and this will decide where do we need to go in the graph's execution, so to node A or to node B, then this is also something that LangGraph also helps us to easily implement. And the last thing is persistence, which I mentioned it. And LangGraph comes with very nice and simple built-in functions that will help us persist our state of the graph. And this will help us also make our software more robust and more fault-tolerant, but also implement some very cool logic that will show you in the course that is going to result us with very nice user experience.