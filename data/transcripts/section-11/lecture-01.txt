Eden: Hey there, Eden here. And in this video, we're going to discuss what's LangGraph and why do we need it, and why it's different from LangChain. So LangChain has been existing for a year and it's an amazing framework for building generative AI applications. If you want to build RAG applications or even agents, LangChain is here to help. It has gone a long way since it was created, and I mean it for the good. It got more secure, more flexible, more readable, and more usable, especially with the LangChain Expression Language. Leveraging composability, the way now to interact with the LangChain components couldn't be more convenient. And LangChain is the open-source framework which is at the moment pioneering a lot of work around agents. And in LangChain, we can build agents, and I even showed it in my LangChain course, how to build agents and what's the logic behind it. However, we do have limitations when we build agents within LangChain. And I think this diagram, which LangChain published when they launched LangGraph, demonstrating the challenges of building complex agentic systems. So, the person with the computer is code, and the person talking, you can think about it as an LLM. The top line represent sequential code that we write. This is deterministic code that simply runs and execute. So we, the developers, have full control of it. At the very bottom, we have agents or autonomous agents, which they can decide what they need to do and how to do it, and they simply do it. And by the way, at the moment, there aren't any autonomous agents which are quite production-ready or usable. So those have the most freedom. When we make a regular LLM call, then the LLM decides what is the output and we have no control of it, but we decide which steps to take before and which steps to take after. But those are very simple applications. For example, you can think of a cybersecurity company that is making a request to the LLM to explain an alert. We can build some useful features with it, but nothing really complex. And when we use LangChain chains, we can have a bunch of LLM calls and we still have control of what happens before and after those calls. So, we can still build some very cool things because we are chaining a lot of LLM calls together and we have more freedom at the moment. Now, within LangChain, we can use something which are called router chains or router agents, which are leveraging LLMs to decide which call to make or what steps to take. And we can easily do it with the LangChain Expression Language, and I showed it in my LangChain course. However, with the LangChain Expression Language, we can't make cycles. We can only have the acyclic graphs. So a certain flow that we write beforehand, but we can't iterate, we can't come back to the original node that we started from and start the process all over again. There are LangChain implementations for those kind of things, but they are ad hoc implementations, like for example, the React algorithm, where there is literally a while loop in the source code. This is exactly where LangGraph blends in. It gives us another dimension of freedom and complexity we can add into our agents. So we can with LangGraph implement cycles. And this feature is super important when we want to build very complex agent that have a certain amount of freedom that we are not used to from before. And the concept of this, it relates to something which is called flow engineering. So we as the developers, we can define the flow of our program and we can blend in with LangGraph the LLM. And the LLM can also help us where do we want to go in the flow, whether to go to flow A or flow B, or to finish, or to go back to where we started and to continue from there. So the cycles gives us a lot of freedom, and with LangGraph, it's very elegant and very easy to implement those kind of solutions. So from the LangGraph documentation, you can see it's listed as building language agents as graphs. So the entire logic, the entire flow of the agent can be expressed as a graph, as a graph with cycles, and this is very convenient. And with LangGraph, we can build some very advanced systems, and we'll even see something like that in the course.