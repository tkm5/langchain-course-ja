Cool. So let me go to Main.py. And here we're going to implement our Landgraaf react graph. And we'll start from the imports. Let's start by first importing from LinkedIn core. Let's import the human message. And this is the input. We're going to start our graph to run with. Now I want to import from Landgraaf. I want to import the messages date object like we had from before, which is going to hold all of our messages. And I want to also import something which is called a state graph. And this is the most generic graph we can have. And it can receive any state object that we want to give it. And this is how we're going to initialize our graph. And when we'll initialize our graph it will be much clearer later in this video. All right let's go and continue. And let's go and import our nodes. I want the run agent reasoning node and the tool node. And now we are done with the imports. Ports. So I want to start by defining some constants. And let's go and define the constant of agent reasoning. We'll call it agent reason. And let's define act as the string act. And this is simply to have cleaner code. So we won't need to rewrite those strings every time that we want to use them. And lastly let's create a new const which is called last which is going to be minus one. And this is for future when we're going to reference the last message between the user and the agent. And the last message is going to be at the minus one index. So this is some Python notation. And again this is simply for more readability when we write the code. So the code is a bit cleaner. Cool. So now it's time to finally implement our graph. Now let's define a new state graph object. Like we are auto populated here. And we want to give it the message graph. So we're going to call it flow instead of graph. And let's go and do that. And now we want to add the nodes like we're autocompleted. So we want to add the node of agent reason and the node of act. And notice how we're using those constants here. And by the way right over here cursor auto completed me this edge from start to agent reason which is correct. But I want to define it in another way. So let me go to the line where we define the agent reason node and one line below it. Let me write flow dot set entry point. And I'm going to set it to Agent Reason. And this is how I personally like to define this edge. It defines an edge from the starting node and going to the agent reason node. Anyways let me go and remove this. And now let's go and add some edges. Let's add the conditional edge from the agent reason node to the node and to the unknown depending of a certain functionality that we write. So I'm going to decide this functionality should continue function which will implement later. And the third argument is going to be a dictionary of mapping between the string end to end from the string act to act. And this mapping over here really tells Landgraf that whatever comes from the should continue function, which is going to be some kind of string. And we're going to return from that function the answering or the x ring. Then we want to map it to go to the end node or to the node with the name of act. So this is going to help us draw those dotted lines over here in the graph itself. And if we didn't write this mapping the graph would still run as we want to. But the drawing wouldn't be that explicit. So this really helps with drawing what we see over here. It defines which nodes can come after the agent reason node, and this is the node and the end node. Alrighty, let's go and implement. This should continue function. So let me go up a bit in the code. And let's go and put it right above here. And this function should continue is going to receive the state of the graph which is going to be a message state. And it's going to return us the string, which is going to annotate the node that should run after the agent reason node. So how we're going to decide we're going to check the messages. And if the last message and this is the usage of the constant here. So if the last message is going to be a tool call then we want to go to the node. And if not we want to go to end. Because if the last message is a tool call. So this means that the LM, the reasoning engine, decided that we need to invoke a tool and it has all the information of the arguments. Then we want to go and execute the tool node which will execute that tool. And if there isn't a tool call, then we simply want to end everything. Because this is a heuristic that the LM was able to answer the question with or without a tool invocation. All right. So we finished implementing those dotted lines over here in the graph. Now let's go and define the edge from act to agent reason. Because after we invoke the tool we want the agent to reason and to figure out whether it needs to return the answer or to run another tool call. And that's pretty much it for the graph. So we defined the nodes, the entry point, the edges between the nodes. And now we want to compile the graph. And let's go and print it and see that we get the same drawing that I'm showing you in the video. And for that we'll use the get graph and then draw Mermod pg function, which will print it and display it. And in the output file here which we're going to call flow PNG. Let's wait for it to run and we can see we get here an error. It seems that we cannot import messages. State message states here. And this is because I'm missing here an S. This is something a cursor made a mistake. So let me go and fix it and let's go and rerun it. And we can see we forgot to update the rest of the code to use messages state instead of message state. So let me copy that and let me put it over here. And we should also do it in the should continue function. So let me go and fix it as well. Yeah. Let me run it again. Now boom. So let's check out now the drawing of the graph. And we can see this is the graph that I showed you during this video. Awesome. So in the next video we're going to test everything. And we're going to review the traces. And we're going to see exactly how everything is working.