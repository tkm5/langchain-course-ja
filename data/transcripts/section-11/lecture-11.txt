All right. So now we want to invoke the graph. So let's write app dot invoke. And let's give it the input. The input is going to be a dictionary with the messages key. And this is going to be a list of human messages in the content here is going to be for example what is the weather in Tokyo. List it and then triple it. And because we need here some real time information here, we're expecting that the agent will first deduce that it needs to call the search tool to search for the weather in Tokyo. And then after we get this result, it needs to invoke another tool, the triple tool. So after it invokes both tools, it will be able to answer the question. So this is what we're expecting here. So let's go now and let's print the result and let's go. And we want to take the last message and to take the content. Let me change the index here to last the const. And this should run. And let's see what happens here. We're still waiting for our result. So far it looks like it's running and boom! Let's take a look at the output here. So this is the current weather in Tokyo. It listed a bunch of metrics and then it took the humidity which is 69. And it multiplied it by three which is 207. So I wasn't that explicit. So let me write what is the temperature in Tokyo listed. And then triple it. Let's see what we get there. So it's still running. Notice it runs a bit long because it makes a bunch of tool calls. So it first needs to reason which is an LM call. Then it needs to call the tool. Then it needs to reason again. And we got here. The current temperature in Tokyo is 15 Celsius and triple it giving 45. So the line graph agent is working as expected now. And I think now in order to understand a bit more about what's happening with the flow, let's go and open Langschmidt and let's check out the traces of the graph execution, and let's see the nodes execution. And the tool calls to really see it with our eyes. So I'll go here to the react function calling project. And you see we have here two traces. Let me go and open the second one. So here we see something actually very interesting. Right from the get go we see that the search tool was called twice. And maybe we should expect it to be called once. But for my experience, this kind of behavior is actually quite regular because because this is a search result, then sometimes we don't get the right result. And sometimes the information that we find online is not enough. So in that case, the agent is smart enough to detect it and to run the tool again until it gets the answer. And by the way, from my experience, a technique if you want to save those tool calls For example, in the cavity search tool we can add an argument of max results. So this is the number of results that will return us. So we can configure it to not be only one result but to be five results for example. And then one of those results for sure is going to have the answer that we want. I mean that's the heuristic. It's not for sure, but it's a heuristic. So let's go and check out the trace one by one from the beginning. Let's go and check out the agent node here. The agent reason. So we can see now that we have here um our system message. And we supplied both tools here. And we see we got the answer that we should invoke the search tool here. And we should invoke the search tool with the current temperature in Tokyo. So let's go and check out now the second node we should continue. So the should continue is actually not a node. It's the conditional edge function. And right over here we can see that this is the input it gets. It checks the last message which is going to be an AI tool call. And besides it should go to the Act node. So then the graph goes to execute the node where it invokes then executes the search function. So we can see it right over here. And the input is the current temperature in Tokyo. And here we got the result here. And notice that in this search query the content that we get doesn't really contain the temperature in Tokyo. So and this is really a non-helpful search result. So what happens then because we have an edge from the node to the agent region. We're then going to give the agent this result of this tool. And it's going to figure out whether it can return the answer or it needs to do something else. So we can see here we are giving also the tool result to the reasoning engine to the reasoning node. And then it decides that it needs to run another search with the current temperature in Tokyo. And this time we can see we have here an included domain here. So we can see here that after it goes to, the should continue conditional edge, and it decides that it needs now to go and do the Act node. Let me go and open that. You can see it's right over here. Act and let's go now to the second search result. Let's go for that. All right. So here we can see that in the content of the search query we have that we have 15Â°C which is much better than before. So now we need to go to the node. And now the agent reason is going to have the valid search here. And we can see now that it decides that it should call the triple function with the input num to be 15, which is extracted from the previous tool call. So this is exactly what we wanted to happen. It then goes and executes the triple tool in the tool node. So it's going to receive the input of 15. Then the result is going to be 45. And I'm not going to go over it. It's pretty trivial. And I'm attaching to this video's resources, this trace, which I'm going to make public. Right. So at the end, the final node that is going to be execute is going to be the agent reason. And then it decides that it doesn't need to do anything right now. So it should finish. All right. So let me go and let me go and commit this code here. So let me add the files and let me commit now and let me call this commit graph. Going to push it to the repo. And you can find the code for this section. Let me go here. So this is the graph commit with all the code that we just wrote. I hope you enjoyed this section. And the entire goal of this section was to show you how easy it is to implement the react agent with graph. So not only are you using graph here, but we leverage function calling. And this actually gives us a lot of stability and better performance for our react agent.