All right. So finally in this section we're going to build our graph. And we're going to connect all the nodes and edges together. So let's go to the code. We first want to go to the init file under the nodes module. So here we want to import all of the nodes we created. So it's going to be the generate node the create documents node the retrieve node the the web search node. And we want to be able to import them from outside the package. So that's why we're going to use the underscore all. And here we're going to put the string names of those nodes. So this will make all of those nodes importable from outside packages. Alrighty. Now I want to go to const py file. And let's define a bunch of constants. And all of those cons are going to be the node names that we're going to refer to in the graph. And the reason we do this is to avoid code duplication. So every time we'll reference the nodes we'll reference the const. And if we want to change the name from some reason we will only need to change it in one place. So that's why I put it in the const file. So we defined the retrieve const with capital letters. And the value is going to be lowercase retrieve which is going to be the name of the retrieve node. Similarly to what we see on the graph of our right. Alrighty, now it's time to go to the graph.py file, and let's finally build an orchestrator graph. So we first want to start with the imports. Let's start by importing load dot env to load the environment variables. We also want to import from graph the add node and the state graph. And we want to import all of our costs that we defined earlier which are going to be the nodes names. And now we want to import all of the nodes we created in the earlier sections. So we'll import the generate node, the greet documents, the retrieve node and finally the web search node. And finally we want to import the graph state which we created in the states py paid for. All right, so if we take a look at the graph from our right, then we can see that after the great documents node we have two edges. One is going to the web search. And this is if we found at least one document that is not relevant to the question. And we have an edge to the generate node. So this is if all documents are valid and are related to the question. And this is going to be our graph conditional edge. So let's go and define the function that will decide which node are we going next. So it's going to output either the web search node or the generate node according to the conditions we described just now. So we'll define the function we'll call it decide to generate which will accept the graph state. And if the web search flag in our state is going to be true. And this means that we found a document that is not relevant to the user's query. So this is the heuristic that in this case we want to search online. So here we would like to return the web search node. Now notice I'm returning the const. And this is the name. And if not and this means that all of the documents we retrieved were relevant to the query. So here we want to return generate. So the graph execution will move to the generate node. And now let's do the easiest part which is connecting everything together. So we'll create our flow. We'll call it workflow. And it's going to be the graph state graph where the state is the state we defined. And we'll use the add node functions to add all of the nodes currently not connected. So we added four nodes and they retrieve node is going to run the retrieve function. Now notice that the retrieve name is lowercase like we see in the picture. From our right. We have the Great Documents node which is going to run the Great Documents function, the generate node, and the web search node. Let's now add the entry point to be the retrieve node. So this is the first function which is going to run to retrieve the documents. We then want to move into the Great Documents node. So we'll add an edge between the retrieve node and between the Great Documents node. And now we want to add the conditional edge from the great nodes to either web search or the generate node. So we're going to use the add conditional edge function from the great documents. This is the source node. The function which will decide which node is going to be executed. Next is going to be decide to generate which we implemented. And the third argument which is going to be the path map. I'm going to put here a dictionary from web search to web search and from generate to generate. And the reason I put it here is simply to show you that there is this option, and what this will do if we put here other names in the values. For example, if instead of web search as the value would put end, then this would be a simply different mapping to go to. So it's useful when the function you implement that decides which node to go to is not returning the node names. And again in this function we we implement it? We don't really need them. I simply wanted to show you that this option exists. Alright, so after we execute the web search node, we have the results and we're ready to go to the generate node. So let's add the edge from web search to generate. And now we want to add the last edge from generate to end. And that's it. We finished building our graph. Let's compile it. And we also want to print it. We'll print it into graph PNG. And finally we are done with our graph. So now let's go to the main.py file. And let's import the graph. And let's invoke it with the questions of what is agent memory. Alrighty, let's go and run this baby. And from our prints we should see the graph structure. So we can see we achieved the documents. We checked relevance. We saw which documents are relevant or not. We saw that one document was not relevant, so we executed the external search. We then went to the generate node and finally we had the response. And the response we got was pretty good. Let's go and check out the graph png. So this is the exact graph we see from our right. And let's go to lengths to trace our graph execution. And let's take the last trace over here. And we can see we have all the nodes that we executed from their order. We can see. For example let's take a look at the web search. And we can see that we executed here with the search item of what is agent memory. Alrighty. And last thing, if you want to check out the code, please go and visit the GitHub repository in the branch line graph and you should see the entire implementation you just saw there. Updated with the latest line chain and line graph versions.