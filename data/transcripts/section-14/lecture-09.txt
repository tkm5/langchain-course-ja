Alrighty. In this video, we'll implement the web searching node. We'll be leveraging the search engine, which is highly optimized to downstream search results, into an LLM based application. And to use Tavileh, we need to make sure we have in our dot env file the Tavileh API key. Let's go to the code and let's add a new file under node. And we want to call it web search. And here we want to start with the imports to import typing. We want to import the Lang document class because we want to convert the search results into a Lang document. And finally we want to import the search class, which is a link chain tool that runs the search engine on the queries. We will provide it. All right. So let's now also import the graph state. And finally, we want to create an object of the Search results tool. Let's initialize it with max results equals to three. So we'll get at most three results. And let's define our function. We'll call it web search. And it will receive the state and return a dictionary will print something just for debugging. And we'll extract the question and documents from the graph state. Now notice because we execute the web search node only after we grade the documents. So it's after we filter them out. So we're not supposed to have any non-relevant documents. So all of the documents we're going to have in the documents list are going to be relevant for our query. All right. We're going to debug this file soon. So I'm going to import the environment variables and make sure that I have my API key in my env file. Let's add some if name equals main. And we're going to plug in the question to the agent memory and the documents to be none. So we don't want to put anything at the moment. This is the scenario where we didn't find any relevant documents at all. All right. So now we want to invoke the search tool, and we want to invoke it with the query to be our question. So let's debug it. And we want to examine the results we get from Tavelli. So because we limited the max results to be three, we're supposed to have here only three search results. And we can see it right here we have a list of three elements. And every element is a dictionary with the content key and the URL key. And what we want to do is to take all the content from all the elements of this list, and to combine them into one document of length chain. So that's what we're going to do next. Alrighty. So let's go back to the code. And let's stop debugging and let's add it. So we want to iterate through every element on the list. And we want to use the join function with backslash n to take the elements in the key of content and to simply join everything together. So we get only one huge string. All right. Now let's run this in debug. And let's see that we get indeed this string. And I'm going now to evaluate this expression. And we can see we have one big string. Now we want to take this string. And from it we want to create a long chain document where its content is going to be this big string. So I want to create a new variable called web results. And it's going to be a document. And in the page content I'm going to give the joint result. And if we currently have documents in our state then those are relevant documents. So we want to append to this document, list the document that is containing the web search. And if not, then this means that we didn't find any document that's relevant, and we simply want to put in the documents a list with one element, which is the web results. And finally, we want to return and update the state of our graph execution. So in the documents key we're going to put the documents. And in the question we're simply going to keep the original question. And that's it for the web searching node. Very straightforward. And the last thing I want to do in this video is to simply rename the file name. So I will go and rename it. And I simply want to add here an underscore. So I'll call it web underscore search.