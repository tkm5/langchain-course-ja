Hey there Eden here. And in this video we're going to review the repository structure. Now we're going to organize our code. So it would be readable. It will be easier to maintain and to write testing. So our application will be more robust. And while this video series was inspired by the Link Chain Team's work implementing advanced RAC solution with Landgraf and their tutorial, I had to make some refactoring. Since the tutorial was more focused on a Jupyter notebook rather than a robust software that is supposed to run in production. Now, I always like to say that our repository structure should reflect our architecture, and in our case, it's going to be our graphs architecture, the nodes and edges that will be implementing. And most of our implementation is going to be in the graph package that will create and it will have the graph py file. And that's going to be where we're going to connect all of our nodes and edges. We're going to have the state py file, which is going to have the graph state object that will be modifying during the graph execution. We also want to have a const py file for constants that we want to use in the implementation, and we want to have a subpackage called nodes. And it's going to have all of the implementation of the nodes that are going to run. So in that package is going to have a lot of files where each file is going to be a node. And we're going to have the chains package where each file in the chains package is going to be a different chain, and it should correspond to the nodes that we're creating, because each node is eventually going to run a long chain chain. Now finally, we also want to be writing tests. So I created a test package and I created a test chains file. So here we're going to be implementing our test for the chains that we're going to write. And finally we also want to write an ingestion file which is going to be holding all of the logic that will download the information we want to index, and it's going to index it in the vector store. Now, before we begin and create all of this structure, I just want to note that this is something that works for me. I'm not claiming that this is the best project structure for a graph application. I'm just saying that this is something that works well for me, for my experience, and you'll see that once we develop this application, it would be very easy to start and to improve it and to make this application more robust with tests. Or we want to make it more complex with more nodes and edges. So this is just as an FYI. All right. Let's go to the code. Now notice that the branch is two project structure. So you can find here the final code for this video. Let's go and create now a new package. And we want to call this package graph. We want now to create a new file in graph package and we'll call this file state py. This will hold our graph state. Now let's go and create another Python file and we'll call it graph. And here we're going to write all the nodes and edges and connections between them. Finally we want to create a const file for constants that we're going to be using mainly names of nodes. And under graph we want to create a new sub package. And we want to call it nodes. And it's going to have all of our nodes implementation. So each node is going to be a file in this package. And every node is eventually going to run a chain. So I want to create a new change package. And here every file is going to be a new chain that should correspond to our nodes package. And we're going to be running tests for those chains. So let's create another sub package under chains. And we want to call it tests. And I want here to add now a new file. And I'm going to call it test chains. And this is going to have all of the testing implementation. And I have to add that the naming convention here is very important because we're going to be leveraging Pytest to orchestrate and run our tests. And Pytest is going to be looking for directories, which starts with tests, and it's going to look for test files with the prefix of test. Let's now add a dummy test to this project under Test chains. So I'm going to define a new function I'm going to call it test foo. And it's going to not return anything. And here I simply want to assert that one is equal to one. So this test should pass. And now I want to test that everything is working. And Pytest is able to run the tests. I will write in the terminal pytest dot to tell Py.test to run from the current directory, which is the root directory of the project is to display from stdout. Dash V is the verbose flag, which is going to show the tests that we ran in pytest, and we can see that Pytest ran the test as we wanted. It ran test foo from the test chains file, and now let's configure our runner to run our tests through the PyCharm runner. Let's go to the top right to Edit configurations. Here we want to click the plus button and to add Python tests and to select Pytest. And here we want to give here the um the directory to be the root directory here this is the script path. And the parameters is going to be dot dash dash v like we saw earlier. And now if we'll take a look we have here test chains and we can simply um run it. So let's go and run it. And we can see we ran the test successfully and if we want, we can even see the exact execution. So this is going to be convenient when we're going to be writing and running our tests. Cool. So we're almost done with the project structure. Now we want to create another file under our root directory for our vector store ingestion. And we'll call it ingestion. And that's pretty much it. We've now created the structure for our repository. And in the next video series we're going to be implementing all of those files. And we're going to be adding more files to this structure. And if you want to compare your code or to even download it, you can go and check out the two project structure branch, where we have all of what we saw in this video there. In the next video we'll be implementing our vector store ingestion to chroma DB.