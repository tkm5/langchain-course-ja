And let's now go and rerun everything. And here we see that we initialize the session, we process the request of list tools. And then we had a request of call tool. So our graph agent our graph react agent which is our MCP host use the MCP client in order to invoke the add tool that the MCP server exposes. And if I will go to the MCP flow of the protocol, then the query we send to our app host. Then it sends to the LM the same query plus all the information about the MCP tools. So then the LM responded that it should go and run the add function with the correct arguments. So it's going to be two two. And something very cool happened here. So instead of the agent running and executing the tools in the actual graph application, what's happening is that the graph agent, with the help of the MCP client, is making a request to the MCP server, and the actual execution of the tool is happening in the server side, which is decoupled from our graph application. So our graph application is responsible for the orchestration. And the MCP server is responsible for the execution of the tools. This is one of the benefits of combining land graph and link chain with MCP. Alrighty. So after we execute it in the server side, the tool we send back the response to the MCP client which forwards it into our graph agent, which then sends the original query with the tool execution answer to the LM. The LM is then going to process it, and it's going to output as the final answer in this case. And this is what's being forwarded to the user by our application. So let's go back here to the final answer. And the final answer is two plus two is equal to four. And let me now go and change here instead of two. Let's put here for example 54. And let's make this example a bit more complicated. And let's add here times three. So we have here two invocations of the tool here. So let's go and rerun everything. And we can see we actually get three tool calls. And for me it's a surprise because I thought we would get two one call. It's going to be two times three which is going to output six. And the other two will call is going to be six plus 54. So we'll check in the trace soon and we'll see soon what's happening here. And let's wait for the result. The result here is 60. So the answer here is correct. So to complete the picture I want to go into lengthy tracing. And I want to see exactly what were the tool calls and to see what was this mysterious extra tool call. Alrighty. So let me open links meat and here I will go to MCP test. This is the project I'm tracing right now. And here we have two traces of our graph executions. So one is going to be for the two plus two query. And the other is going to be for the 54 plus two times three query. By the way I made those traces public and I am sharing them in the videos resources. So you can see exactly what I am seeing right now. If you didn't do it for yourself, let's open the two plus two trace and let's examine what are the calls made to the LM. And let's go and select here this instance of chat OpenAI message. And here we're seeing the trace. And we can see that we made a request with function calling. So we can see here the tools we have here. This is the tools that the graph agent sent. And we can see we have here with the add and then multiply tool. And we can see that the LM responded with the add tool that needs to be called. And we can see it by this called tag over here. So the input was what is two plus two. So this was the exact input of the original query. The augmentation with the tools that Landgraaf did for us was here. And the result is this tool call with those arguments here. So the MCP client then made a request to the MCP server with the input of two plus two. So we executed the tool in the MCP server. And this is the tracing of this execution. And we can see here the input is two and two and the output is four. And something interesting to note is that in this trace here we can't really see that the tool was actually executed on the MCP server, which is completely decoupled from the graph graph. So we can't really see it even by inspecting the metadata here. But I'm positive that the LinkedIn team is going to update this, and it's going to make this more visible and more noticeable for agents which leverage MCP servers. Anyways, here we can see now the final answer. So we have here the original prompt the tool call. And we get here the final answer which is four. And the last thing I owe you for this session is to show you this extra mysterious tool call that we had in the second round. And if we'll open the first request to the LLM. So this is the original prompt alongside the augmentation of the MCP tools here. Then we can see that the output we get back from the LLM is a multiple tool call. So we have here two tool calls. One is going to be 54 plus zero. And this is the extra tool call that I missed. And the other is going to be two times three. And an interesting thing with graph by the way is that it's going to run those tool calls concurrently. So it's going to make two concurrent requests into our MCP server. So one request is going to be to add 54 and zero. And the other request is going to be to multiply two and three. And you can see that they are concurrent because they are starting in the same start time, the same timestamp of 1131 and 17 milliseconds. And the rest of the execution is pretty straightforward. After we have the result from the MCP server of how much is two times three, we can send another request to the Lem with this observation with this result. So let's go and check it out. And here we are sending now the Lem, the same query but with the result of the tool call. And then the Lem is going to decide that it needs to add up 54 and six. So let's go and see if this tool execution here. And the rest is pretty straightforward. We send this final result to the LM again, alongside with the history of what we did. And then we get the final answer and let's go and let's check out the final answer here. And that's it. Let me go now and go back to cursor and let me go and add the implementation here. And let's commit it to GitHub. So I'm going to use again the cursor feature of creating the commit message. Let me commit that and let me push to the repository. All right so you can see the final artifact. Let's go to the GitHub repository. So the final artifact is going to be here in this branch. And you can see here that this is the code.