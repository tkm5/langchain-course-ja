Alrighty, so now it's time to test our graph and let's invoke it with an input. And in the input I wrote make this tweet better. And then I plugged in a tweet I wrote a while ago about Link Chains new feature tool calling, which provide us with a single interface for function calling. So that was pretty big because up until then, then only OpenAI function was supported. But now with this single interface, we can use Gemini, we can use entropy cloud, and we can use any model that supports function calling. So let's try and see what the graph says about this tweet. We'll run graph dot invoke and we'll give it the inputs. And let's run it. Now the graph is executing. If we'll go to link and we'll go to our reflection agent project, we can see we have a trace which is still running. And let's wait until it finishes and let's go and open this trace. And first of all, let's notice that it took almost 20s to run. And this makes sense because we made tons of API calls to the LLM. And if we go to the final prompt to the LLM, then we can see that the output that we got is the final tweet after all the reflection. Now, I'm definitely not a copyright expert, but what I want to show you is the process and what the LLM did to get to this output. So it would be easier to see the final prompt to the LLM, because it has already all the history and all the interaction of the agent with the LLM. So we can see we first started with a system message that you are taking, influencer tasked with writing excellent Twitter posts, blah blah, blah. And then I wrote make this tweet better. And then we started the graph iteration. And the first thing is to generate a revision for this tweet with the generate general note that we did. We didn't finish our iterations, so we went into the reflection mode and we can see the response we got back from the LM, which is artificially tagged here as human, is giving us feedback about this tweet. So after we finish this node, then we need to go back to the generate node. We generate another tweet according to this feedback and so on and so on until we go and until we have the final output which is this one. And you can see on the left side length chain even have traceability and observability for lane graph objects. So we have the should continue. We have the reflection nodes. And we have all of our graph objects built in into our trace. Cool. So we implemented a very slim version of a critiquing algorithm using graph. Now we could have done it with link chain, but look how simple it was with graph.